function [X, T, U] = CTSolve(J, sigma, p, Q, Ns, Xe, varargin)
%Solve FEM problem using a Combination Technique and return the solution
%evaluated over the provided grid.
% 
% Arguments
%   J           : (Int) Index for the highest refinement
%   sigma       : (Float) Anisotropic parameter
%   p           : (struct) Problem structure generated by WaveProblem.m
%   Q           : (struct) Domain structure generated by Domain.m
%   Ns          : (Int[][]) Matrix with two columns: x-component number of 
%                   elements and t-component number of elements.
%   Xe          : (Float[][]) Matrix with two columns: x-component of knots 
%                   in grid evaluation and t-component of knots in grid 
%                   evaluation
%   cols (*)    : (Bool) decide if taking subspace-sum by cols or rows
%
% Returns
%   X           : (Float[][]) Matrix of x coordinates of points for eval
%   T           : (Float[][]) Matrix of t coordinates of points for eval
%   U           : (Float[][]) Matrix of evaluation of solution u(x, t)

    %% Unpack parameters
    % Split element matrix
    nxs = Ns(:, 1);     nts = Ns(:, 2);
    % Split point evaluation matrix
    ep_x = Xe(:, 1);    ep_t = Xe(:, 2);
    % Unpack varargin
    if isempty(varargin)
        cols = true;
    else
        cols = varargin{1};
        Wqxt = varargin{2};
    end

    %% Compute combination coefficients and create meshgrid
    % CT Coefficients
    [c1, c2] = CombinationCoefficients(J - 1, sigma, cols);
    % Generate X and T
    [X, T] = meshgrid(ep_x, ep_t);

    %% Iterate over CT coefficients
    % Define combination technique solution
    U = zeros(length(ep_t), length(ep_x));
    
    for k = 1:length(c1)
        for i = 1:2
            j1 = c1(k) + 1;     j2 = c2(k) + 1;
            if i == 2
                if cols
                    j2 = j2 - 1;
                else
                    j1 = j1 - 1;
                end
            end

            % Define evaluation of solution
            u_eval = zeros(length(ep_t), length(ep_x));

            if j1 > 0 && j2 > 0
                % Create parameters and solve with SolverWaves
                d = Discretization(nxs(j1), nts(j2), Q);
                fprintf("Solving for nx=%i and nt=%i\n", nxs(j1), nts(j2));
                mesh = CartesianMesh(d);
                u = SolverWaves(p, Q, mesh, d, 1e-2, 1e1);

                % Evaluate solution
                u_eval = SolutionGridEval(u, mesh, d, ep_x, ep_t);
                ex_eval = p.u(X, T);
                err = u_eval - ex_eval;
                
                if length(varargin) > 1
                    % Compute L2 error of each subproblem solved
                    fprintf("L2error: %d\n", sqrt(sum(err(:) .* err(:) .* ...
                        Wqxt(:))));
                end
            end
            % Update CT solution
            U = U + (-1)^(i + 1) * u_eval;
        end
    end
end